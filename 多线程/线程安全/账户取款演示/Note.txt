总结:

synchronized执行原理:(结合Account代码)
    1.假设t1和t2线程并发:开始执行代码的时候,肯定有一个先一个后
    2.假设t1先执行了,遇到了synchronized,这个时候自动找"后面共享对象"的对象锁,
    找到之后,并占有这把锁,然后执行同步代码块中的程序,在程序执行过程中一直都是
    占有这把锁的.直到同步代码块代码结束后,这把锁才会释放.
    3.假设t1已经占有这把锁,此时t2也遇到synchronized关键字,也会去占有后面
    共享对象的这把锁,结果这把锁被t1占有,t2只能在同步代码块外面等待t1的结束,
    t2占有这把锁之后,进入同步代码执行程序.

synchronized有三种写法:

    第一种:同步代码块
        灵活,小括号中可以放任意线程共享对象
        表示找对象锁
        每创建一个对象,就同时存在一个对象锁
        synchronized(线程同步对象){
            同步代码块;
        }

    第二种:在实例方法上使用synchronized
        表示共享对象一定是this,并且同步代码块是整个方法体
        这种方式不太灵活.
    
    第三种:在静态方法上使用synchronized
        表示找类锁
        类锁永远只有1把,那类锁也只有一把.

    


